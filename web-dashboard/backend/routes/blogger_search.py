import logging
import statistics
from datetime import datetime
from typing import List, Dict, Any, Optional
from fastapi import APIRouter, HTTPException
from fastapi.responses import StreamingResponse
from pydantic import BaseModel
import asyncio
from io import BytesIO
import aiohttp
import re

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logger = logging.getLogger(__name__)

router = APIRouter(tags=["blogger_search"])

# –ò–º–ø–æ—Ä—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
try:
    from config import SERPER_API_KEY
except ImportError:
    # Fallback –µ—Å–ª–∏ config.py –Ω–µ –Ω–∞–π–¥–µ–Ω
    SERPER_API_KEY = "your_serper_api_key_here"

# === –ú–æ–¥–µ–ª–∏ –¥–∞–Ω–Ω—ã—Ö ===

class BloggerSearchRequest(BaseModel):
    keyword: str
    platforms: List[str] = ["youtube", "instagram", "tiktok", "telegram"]
    min_followers: Optional[int] = None
    max_followers: Optional[int] = None
    min_budget: Optional[int] = None
    max_budget: Optional[int] = None
    country: Optional[str] = None

class BloggerContact(BaseModel):
    telegram: Optional[str] = None
    email: Optional[str] = None
    instagram_dm: Optional[str] = None
    whatsapp: Optional[str] = None

class BloggerStats(BaseModel):
    avg_views: int
    avg_likes: int
    avg_comments: int
    engagement_rate: float
    posts_per_month: int
    wb_mentions: int

class AudienceInsights(BaseModel):
    age_18_24: float = 0.0
    age_25_34: float = 0.0
    age_35_44: float = 0.0
    age_45_plus: float = 0.0
    male_percentage: float = 0.0
    female_percentage: float = 0.0
    top_countries: List[str] = []

class BloggerDetail(BaseModel):
    id: int
    name: str
    platform: str
    profile_url: str
    avatar_url: Optional[str] = None
    category: str
    followers: int
    verified: bool = False
    has_wb_content: bool = False
    budget_min: int
    budget_max: int
    contacts: BloggerContact
    stats: BloggerStats
    audience: AudienceInsights
    content_examples: List[str] = []
    country: Optional[str] = None
    description: Optional[str] = None
    is_top_blogger: bool = False
    brand_friendly: bool = False

class BloggerAnalytics(BaseModel):
    total_bloggers: int
    platform_distribution: Dict[str, int]
    avg_followers: float
    avg_budget: float
    top_categories: List[Dict[str, Any]]
    wb_content_percentage: float
    top_countries: List[str]

class AIRecommendations(BaseModel):
    best_bloggers: List[str]
    recommended_platforms: List[str]
    budget_strategy: str
    content_suggestions: List[str]
    negotiation_tips: List[str]
    campaign_strategy: str
    expected_roi: str

class BloggerSearchResponse(BaseModel):
    bloggers: List[BloggerDetail]
    analytics: BloggerAnalytics
    ai_recommendations: AIRecommendations
    total_found: int

# === –§—É–Ω–∫—Ü–∏–∏ —Ä–µ–∞–ª—å–Ω–æ–≥–æ –ø–æ–∏—Å–∫–∞ –±–ª–æ–≥–µ—Ä–æ–≤ ===

async def search_youtube_bloggers(query: str) -> List[Dict[str, Any]]:
    """–ü–æ–∏—Å–∫ –±–ª–æ–≥–µ—Ä–æ–≤ –Ω–∞ YouTube —á–µ—Ä–µ–∑ Serper API"""
    logger.info(f"üé¨ –ü–æ–∏—Å–∫ –±–ª–æ–≥–µ—Ä–æ–≤ –Ω–∞ YouTube: {query}")
    
    bloggers = []
    
    try:
        search_query = f"{query} wildberries –æ–±–∑–æ—Ä OR —Ä–∞—Å–ø–∞–∫–æ–≤–∫–∞ OR –æ—Ç–∑—ã–≤ site:youtube.com"
        
        async with aiohttp.ClientSession() as session:
            headers = {
                'X-API-KEY': SERPER_API_KEY,
                'Content-Type': 'application/json'
            }
            
            payload = {
                'q': search_query,
                'type': 'search',
                'engine': 'google',
                'num': 20
            }
            
            async with session.post('https://google.serper.dev/search', 
                                  headers=headers, 
                                  json=payload) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    for result in data.get('organic', []):
                        blogger = parse_youtube_result(result, query)
                        if blogger:
                            bloggers.append(blogger)
                else:
                    logger.warning(f"Serper API error: {response.status}")
                
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –Ω–∞ YouTube: {e}")
    
    logger.info(f"üìä –ù–∞–π–¥–µ–Ω–æ {len(bloggers)} –±–ª–æ–≥–µ—Ä–æ–≤ –Ω–∞ YouTube")
    return bloggers

async def search_instagram_bloggers(query: str) -> List[Dict[str, Any]]:
    """–ü–æ–∏—Å–∫ –±–ª–æ–≥–µ—Ä–æ–≤ –≤ Instagram —á–µ—Ä–µ–∑ Serper API"""
    logger.info(f"üì∑ –ü–æ–∏—Å–∫ –±–ª–æ–≥–µ—Ä–æ–≤ –≤ Instagram: {query}")
    
    bloggers = []
    
    try:
        search_query = f"{query} wildberries –æ—Ç–∑—ã–≤ OR –æ–±–∑–æ—Ä site:instagram.com"
        
        async with aiohttp.ClientSession() as session:
            headers = {
                'X-API-KEY': SERPER_API_KEY,
                'Content-Type': 'application/json'
            }
            
            payload = {
                'q': search_query,
                'type': 'search',
                'engine': 'google',
                'num': 20
            }
            
            async with session.post('https://google.serper.dev/search', 
                                  headers=headers, 
                                  json=payload) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    for result in data.get('organic', []):
                        blogger = parse_instagram_result(result, query)
                        if blogger:
                            bloggers.append(blogger)
                else:
                    logger.warning(f"Serper API error: {response.status}")
                
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –≤ Instagram: {e}")
    
    logger.info(f"üìä –ù–∞–π–¥–µ–Ω–æ {len(bloggers)} –±–ª–æ–≥–µ—Ä–æ–≤ –≤ Instagram")
    return bloggers

async def search_tiktok_bloggers(query: str) -> List[Dict[str, Any]]:
    """–ü–æ–∏—Å–∫ –±–ª–æ–≥–µ—Ä–æ–≤ –≤ TikTok —á–µ—Ä–µ–∑ Serper API"""
    logger.info(f"üéµ –ü–æ–∏—Å–∫ –±–ª–æ–≥–µ—Ä–æ–≤ –≤ TikTok: {query}")
    
    bloggers = []
    
    try:
        search_query = f"{query} wildberries –æ—Ç–∑—ã–≤ OR –æ–±–∑–æ—Ä site:tiktok.com"
        
        async with aiohttp.ClientSession() as session:
            headers = {
                'X-API-KEY': SERPER_API_KEY,
                'Content-Type': 'application/json'
            }
            
            payload = {
                'q': search_query,
                'type': 'search',
                'engine': 'google',
                'num': 20
            }
            
            async with session.post('https://google.serper.dev/search', 
                                  headers=headers, 
                                  json=payload) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    for result in data.get('organic', []):
                        blogger = parse_tiktok_result(result, query)
                        if blogger:
                            bloggers.append(blogger)
                else:
                    logger.warning(f"Serper API error: {response.status}")
                
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –≤ TikTok: {e}")
    
    logger.info(f"üìä –ù–∞–π–¥–µ–Ω–æ {len(bloggers)} –±–ª–æ–≥–µ—Ä–æ–≤ –≤ TikTok")
    return bloggers

async def search_telegram_bloggers(query: str) -> List[Dict[str, Any]]:
    """–ü–æ–∏—Å–∫ –±–ª–æ–≥–µ—Ä–æ–≤ –≤ Telegram —á–µ—Ä–µ–∑ Serper API"""
    logger.info(f"‚úàÔ∏è –ü–æ–∏—Å–∫ –±–ª–æ–≥–µ—Ä–æ–≤ –≤ Telegram: {query}")
    
    bloggers = []
    
    try:
        search_query = f"{query} wildberries –æ—Ç–∑—ã–≤ OR –æ–±–∑–æ—Ä site:t.me"
        
        async with aiohttp.ClientSession() as session:
            headers = {
                'X-API-KEY': SERPER_API_KEY,
                'Content-Type': 'application/json'
            }
            
            payload = {
                'q': search_query,
                'type': 'search',
                'engine': 'google',
                'num': 20
            }
            
            async with session.post('https://google.serper.dev/search', 
                                  headers=headers, 
                                  json=payload) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    for result in data.get('organic', []):
                        blogger = parse_telegram_result(result, query)
                        if blogger:
                            bloggers.append(blogger)
                else:
                    logger.warning(f"Serper API error: {response.status}")
                
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞ –≤ Telegram: {e}")
    
    logger.info(f"üìä –ù–∞–π–¥–µ–Ω–æ {len(bloggers)} –±–ª–æ–≥–µ—Ä–æ–≤ –≤ Telegram")
    return bloggers

# === –§—É–Ω–∫—Ü–∏–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ ===

def parse_youtube_result(result: Dict, query: str) -> Optional[Dict]:
    """–ü–∞—Ä—Å–∏–Ω–≥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –ø–æ–∏—Å–∫–∞ YouTube"""
    try:
        url = result.get('link', '')
        if 'youtube.com' not in url:
            return None
        
        title = result.get('title', '')
        snippet = result.get('snippet', '')
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –¥–∞–Ω–Ω—ã–µ
        channel_name = extract_youtube_channel(title, url)
        views = extract_views_from_snippet(snippet)
        audience = estimate_audience_youtube(views)
        followers = estimate_followers_from_audience(audience)
        
        blogger = {
            "name": channel_name,
            "username": extract_youtube_username(url),
            "platform": "youtube",
            "url": url,
            "post_title": title,
            "post_snippet": snippet,
            "estimated_audience": audience,
            "views": views,
            "followers": followers,
            "topic": classify_topic(title + " " + snippet),
            "has_wb_content": check_wb_mentions(title + " " + snippet),
            "budget_range": estimate_collaboration_budget("YouTube", views),
            "contacts": extract_contacts(snippet),
            "engagement_rate": estimate_engagement_rate(views, followers)
        }
        
        return blogger
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ YouTube —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞: {e}")
        return None

def parse_instagram_result(result: Dict, query: str) -> Optional[Dict]:
    """–ü–∞—Ä—Å–∏–Ω–≥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –ø–æ–∏—Å–∫–∞ Instagram"""
    try:
        url = result.get('link', '')
        if 'instagram.com' not in url:
            return None
        
        title = result.get('title', '')
        snippet = result.get('snippet', '')
        
        username = extract_instagram_username(url)
        likes = extract_likes_from_snippet(snippet)
        audience = estimate_audience_instagram(likes)
        followers = estimate_followers_from_audience(audience)
        
        blogger = {
            "name": extract_display_name(title) or username,
            "username": username,
            "platform": "instagram",
            "url": url,
            "post_title": title,
            "post_snippet": snippet,
            "estimated_audience": audience,
            "views": likes,  # –î–ª—è Instagram –∏—Å–ø–æ–ª—å–∑—É–µ–º –ª–∞–π–∫–∏ –∫–∞–∫ –º–µ—Ç—Ä–∏–∫—É
            "followers": followers,
            "topic": classify_topic(title + " " + snippet),
            "has_wb_content": check_wb_mentions(title + " " + snippet),
            "budget_range": estimate_collaboration_budget("Instagram", likes),
            "contacts": extract_contacts(snippet),
            "engagement_rate": estimate_engagement_rate(likes, followers)
        }
        
        return blogger
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ Instagram —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞: {e}")
        return None

def parse_tiktok_result(result: Dict, query: str) -> Optional[Dict]:
    """–ü–∞—Ä—Å–∏–Ω–≥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –ø–æ–∏—Å–∫–∞ TikTok"""
    try:
        url = result.get('link', '')
        if 'tiktok.com' not in url:
            return None
        
        title = result.get('title', '')
        snippet = result.get('snippet', '')
        
        username = extract_tiktok_username(url)
        views = extract_views_from_snippet(snippet)
        audience = estimate_audience_tiktok(views)
        followers = estimate_followers_from_audience(audience)
        
        blogger = {
            "name": extract_display_name(title) or username,
            "username": username,
            "platform": "tiktok",
            "url": url,
            "post_title": title,
            "post_snippet": snippet,
            "estimated_audience": audience,
            "views": views,
            "followers": followers,
            "topic": classify_topic(title + " " + snippet),
            "has_wb_content": check_wb_mentions(title + " " + snippet),
            "budget_range": estimate_collaboration_budget("TikTok", views),
            "contacts": extract_contacts(snippet),
            "engagement_rate": estimate_engagement_rate(views, followers)
        }
        
        return blogger
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ TikTok —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞: {e}")
        return None

def parse_telegram_result(result: Dict, query: str) -> Optional[Dict]:
    """–ü–∞—Ä—Å–∏–Ω–≥ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –ø–æ–∏—Å–∫–∞ Telegram"""
    try:
        url = result.get('link', '')
        if 't.me/' not in url:
            return None
        
        title = result.get('title', '')
        snippet = result.get('snippet', '')
        
        username = extract_telegram_username(url)
        views = extract_views_from_snippet(snippet)
        audience = "–ù–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ"
        followers = 1000  # –ë–∞–∑–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è Telegram
        
        blogger = {
            "name": extract_display_name(title) or username,
            "username": username,
            "platform": "telegram",
            "url": url,
            "post_title": title,
            "post_snippet": snippet,
            "estimated_audience": audience,
            "views": views,
            "followers": followers,
            "topic": classify_topic(title + " " + snippet),
            "has_wb_content": check_wb_mentions(title + " " + snippet),
            "budget_range": estimate_collaboration_budget("Telegram", views),
            "contacts": extract_contacts(snippet),
            "engagement_rate": estimate_engagement_rate(views, followers)
        }
        
        return blogger
        
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ Telegram —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞: {e}")
        return None

# === –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ===

def extract_youtube_channel(title: str, url: str) -> str:
    """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞ YouTube"""
    try:
        # –£–±–∏—Ä–∞–µ–º "- YouTube" –∏–∑ –∫–æ–Ω—Ü–∞
        if title.endswith(" - YouTube"):
            title = title[:-10]
        
        # –ò—â–µ–º –ø–∞—Ç—Ç–µ—Ä–Ω "video_title - Channel Name"
        if " - " in title:
            parts = title.split(" - ")
            return parts[-1]  # –ü–æ—Å–ª–µ–¥–Ω—è—è —á–∞—Å—Ç—å –æ–±—ã—á–Ω–æ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞
        
        return title
    except:
        return "YouTube Channel"

def extract_youtube_username(url: str) -> str:
    """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ username YouTube –∫–∞–Ω–∞–ª–∞"""
    try:
        if '/channel/' in url:
            return url.split('/channel/')[-1].split('/')[0]
        elif '/@' in url:
            return url.split('/@')[-1].split('/')[0]
        elif '/c/' in url:
            return url.split('/c/')[-1].split('/')[0]
        elif '/user/' in url:
            return url.split('/user/')[-1].split('/')[0]
        else:
            return "youtube_user"
    except:
        return "youtube_user"

def extract_instagram_username(url: str) -> str:
    """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ username Instagram"""
    try:
        if 'instagram.com/' in url:
            username = url.split('instagram.com/')[-1].split('/')[0]
            return username if username else "instagram_user"
        return "instagram_user"
    except:
        return "instagram_user"

def extract_tiktok_username(url: str) -> str:
    """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ username TikTok"""
    try:
        if 'tiktok.com/@' in url:
            return url.split('tiktok.com/@')[-1].split('/')[0]
        return "tiktok_user"
    except:
        return "tiktok_user"

def extract_telegram_username(url: str) -> str:
    """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ username Telegram"""
    try:
        if 't.me/' in url:
            return url.split('t.me/')[-1].split('/')[0]
        return "telegram_user"
    except:
        return "telegram_user"

def extract_display_name(title: str) -> Optional[str]:
    """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º–æ–≥–æ –∏–º–µ–Ω–∏"""
    try:
        # –£–±–∏—Ä–∞–µ–º –æ–±—â–∏–µ —Å—É—Ñ—Ñ–∏–∫—Å—ã
        title = title.replace(" - YouTube", "").replace(" ‚Ä¢ Instagram", "").replace(" - TikTok", "")
        
        # –ò—â–µ–º –∏–º—è –≤ —Å–∫–æ–±–∫–∞—Ö
        if "(" in title and ")" in title:
            name_match = re.search(r'\(([^)]+)\)', title)
            if name_match:
                return name_match.group(1)
        
        # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—ã–µ 2-3 —Å–ª–æ–≤–∞ –∫–∞–∫ –∏–º—è
        words = title.split()[:3]
        return " ".join(words) if words else None
    except:
        return None

def extract_views_from_snippet(snippet: str) -> int:
    """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤"""
    try:
        patterns = [
            r'(\d+(?:\.\d+)?)\s*[kK]\s*–ø—Ä–æ—Å–º–æ—Ç—Ä',
            r'(\d+(?:\.\d+)?)\s*[mM]\s*–ø—Ä–æ—Å–º–æ—Ç—Ä',
            r'(\d+(?:,\d+)*)\s*–ø—Ä–æ—Å–º–æ—Ç—Ä',
            r'(\d+(?:\.\d+)?)\s*[kK]\s*view',
            r'(\d+(?:\.\d+)?)\s*[mM]\s*view',
            r'(\d+(?:,\d+)*)\s*view'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, snippet, re.IGNORECASE)
            if match:
                value = match.group(1).replace(',', '')
                if 'K' in match.group(0).upper() or '–ö' in match.group(0).upper():
                    return int(float(value) * 1000)
                elif 'M' in match.group(0).upper() or '–ú' in match.group(0).upper():
                    return int(float(value) * 1000000)
                else:
                    return int(float(value))
        
        return 0
    except:
        return 0

def extract_likes_from_snippet(snippet: str) -> int:
    """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ª–∞–π–∫–æ–≤"""
    try:
        patterns = [
            r'(\d+(?:\.\d+)?)\s*[kK]\s*–ª–∞–π–∫',
            r'(\d+(?:\.\d+)?)\s*[mM]\s*–ª–∞–π–∫',
            r'(\d+(?:,\d+)*)\s*–ª–∞–π–∫',
            r'(\d+(?:\.\d+)?)\s*[kK]\s*like',
            r'(\d+(?:\.\d+)?)\s*[mM]\s*like',
            r'(\d+(?:,\d+)*)\s*like'
        ]
        
        for pattern in patterns:
            match = re.search(pattern, snippet, re.IGNORECASE)
            if match:
                value = match.group(1).replace(',', '')
                if 'K' in match.group(0).upper() or '–ö' in match.group(0).upper():
                    return int(float(value) * 1000)
                elif 'M' in match.group(0).upper() or '–ú' in match.group(0).upper():
                    return int(float(value) * 1000000)
                else:
                    return int(float(value))
        
        return 0
    except:
        return 0

def classify_topic(text: str) -> str:
    """–ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è —Ç–µ–º–∞—Ç–∏–∫–∏ –±–ª–æ–≥–µ—Ä–∞"""
    text_lower = text.lower()
    
    if any(word in text_lower for word in ['–º–æ–¥–∞', '–æ–¥–µ–∂–¥–∞', '—Å—Ç–∏–ª—å', 'fashion', 'outfit']):
        return "–ú–æ–¥–∞ –∏ —Å—Ç–∏–ª—å"
    elif any(word in text_lower for word in ['–∫–æ—Å–º–µ—Ç–∏–∫–∞', 'beauty', '–º–∞–∫–∏—è–∂', 'skincare', '–∫—Ä–∞—Å–æ—Ç–∞']):
        return "–ö—Ä–∞—Å–æ—Ç–∞ –∏ –∫–æ—Å–º–µ—Ç–∏–∫–∞"
    elif any(word in text_lower for word in ['–¥–µ—Ç–∏', '–¥–µ—Ç—Å–∫', '—Ä–µ–±–µ–Ω–æ–∫', 'kids', 'baby']):
        return "–î–µ—Ç—Å–∫–∏–µ —Ç–æ–≤–∞—Ä—ã"
    elif any(word in text_lower for word in ['–¥–æ–º', '–∏–Ω—Ç–µ—Ä—å–µ—Ä', 'home', '–¥–µ–∫–æ—Ä']):
        return "–î–æ–º –∏ –∏–Ω—Ç–µ—Ä—å–µ—Ä"
    elif any(word in text_lower for word in ['—Å–ø–æ—Ä—Ç', '—Ñ–∏—Ç–Ω–µ—Å', '—Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫', 'sport', 'fitness']):
        return "–°–ø–æ—Ä—Ç –∏ —Ñ–∏—Ç–Ω–µ—Å"
    elif any(word in text_lower for word in ['–µ–¥–∞', '–∫—É–ª–∏–Ω–∞—Ä', '—Ä–µ—Ü–µ–ø—Ç', 'food', 'cooking']):
        return "–ï–¥–∞ –∏ –∫—É–ª–∏–Ω–∞—Ä–∏—è"
    elif any(word in text_lower for word in ['—Ç–µ—Ö–Ω–∏–∫', '–≥–∞–¥–∂–µ—Ç', 'tech', '—ç–ª–µ–∫—Ç—Ä–æ–Ω']):
        return "–¢–µ—Ö–Ω–∏–∫–∞ –∏ –≥–∞–¥–∂–µ—Ç—ã"
    else:
        return "–û–±—â–∞—è —Ç–µ–º–∞—Ç–∏–∫–∞"

def check_wb_mentions(text: str) -> bool:
    """–ü—Ä–æ–≤–µ—Ä–∫–∞ —É–ø–æ–º–∏–Ω–∞–Ω–∏–π Wildberries"""
    text_lower = text.lower()
    wb_keywords = ['wildberries', '–≤–∞–π–ª–¥–±–µ—Ä—Ä–∏–∑', 'wb', '–≤–±', '–≤–∞–π–ª–¥–±–µ—Ä–∏–∑']
    return any(keyword in text_lower for keyword in wb_keywords)

def estimate_audience_youtube(views: int) -> str:
    """–û—Ü–µ–Ω–∫–∞ –∞—É–¥–∏—Ç–æ—Ä–∏–∏ YouTube –∫–∞–Ω–∞–ª–∞ –ø–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞–º"""
    if views > 1000000:
        return "1M+ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"
    elif views > 100000:
        return "100K-1M –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"
    elif views > 10000:
        return "10K-100K –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"
    elif views > 1000:
        return "1K-10K –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"
    else:
        return "–ú–µ–Ω–µ–µ 1K –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"

def estimate_audience_instagram(likes: int) -> str:
    """–û—Ü–µ–Ω–∫–∞ –∞—É–¥–∏—Ç–æ—Ä–∏–∏ Instagram –ø–æ –ª–∞–π–∫–∞–º"""
    if likes > 50000:
        return "500K+ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"
    elif likes > 5000:
        return "50K-500K –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"
    elif likes > 500:
        return "5K-50K –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"
    elif likes > 50:
        return "500-5K –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"
    else:
        return "–ú–µ–Ω–µ–µ 500 –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"

def estimate_audience_tiktok(views: int) -> str:
    """–û—Ü–µ–Ω–∫–∞ –∞—É–¥–∏—Ç–æ—Ä–∏–∏ TikTok –ø–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–∞–º"""
    if views > 500000:
        return "500K+ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"
    elif views > 50000:
        return "50K-500K –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"
    elif views > 5000:
        return "5K-50K –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"
    elif views > 500:
        return "500-5K –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"
    else:
        return "–ú–µ–Ω–µ–µ 500 –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"

def estimate_followers_from_audience(audience_str: str) -> int:
    """–ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏ –∞—É–¥–∏—Ç–æ—Ä–∏–∏ –≤ —á–∏—Å–ª–æ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤"""
    try:
        if "1M+" in audience_str:
            return 1500000
        elif "100K-1M" in audience_str:
            return 500000
        elif "500K+" in audience_str:
            return 750000
        elif "50K-500K" in audience_str:
            return 200000
        elif "10K-100K" in audience_str:
            return 50000
        elif "5K-50K" in audience_str:
            return 25000
        elif "1K-10K" in audience_str:
            return 5000
        elif "500-5K" in audience_str:
            return 2500
        else:
            return 1000
    except:
        return 1000

def estimate_collaboration_budget(platform: str, engagement: int) -> tuple:
    """–û—Ü–µ–Ω–∫–∞ –±—é–¥–∂–µ—Ç–∞ —Å–æ—Ç—Ä—É–¥–Ω–∏—á–µ—Å—Ç–≤–∞"""
    if platform == "YouTube":
        if engagement > 100000:
            return (50000, 200000)
        elif engagement > 10000:
            return (10000, 50000)
        elif engagement > 1000:
            return (3000, 10000)
        else:
            return (0, 3000)
    
    elif platform == "Instagram":
        if engagement > 10000:
            return (15000, 50000)
        elif engagement > 1000:
            return (5000, 15000)
        else:
            return (0, 5000)
    
    elif platform == "TikTok":
        if engagement > 50000:
            return (20000, 100000)
        elif engagement > 5000:
            return (5000, 20000)
        else:
            return (0, 5000)
    
    elif platform == "Telegram":
        return (3000, 15000)
    
    return (1000, 5000)

def estimate_engagement_rate(views: int, followers: int) -> float:
    """–û—Ü–µ–Ω–∫–∞ –ø—Ä–æ—Ü–µ–Ω—Ç–∞ –≤–æ–≤–ª–µ—á–µ–Ω–Ω–æ—Å—Ç–∏"""
    try:
        if followers > 0:
            rate = (views / followers) * 100
            return min(rate, 100.0)  # –ú–∞–∫—Å–∏–º—É–º 100%
        return 0.0
    except:
        return 0.0

def extract_contacts(text: str) -> List[str]:
    """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–æ–Ω—Ç–∞–∫—Ç–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏"""
    contacts = []
    
    # Email
    email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
    emails = re.findall(email_pattern, text)
    contacts.extend(emails)
    
    # Telegram
    telegram_pattern = r'@[\w\d_]+'
    telegrams = re.findall(telegram_pattern, text)
    contacts.extend(telegrams)
    
    return contacts

# === –§—É–Ω–∫—Ü–∏–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∞–Ω–Ω—ã—Ö ===

async def search_real_bloggers(keyword: str, platforms: List[str]) -> List[Dict[str, Any]]:
    """–ü–æ–∏—Å–∫ —Ä–µ–∞–ª—å–Ω—ã—Ö –±–ª–æ–≥–µ—Ä–æ–≤ —á–µ—Ä–µ–∑ API"""
    
    all_bloggers = []
    
    # –ó–∞–ø—É—Å–∫–∞–µ–º –ø–æ–∏—Å–∫ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ –Ω–∞ –≤—Å–µ—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞—Ö
    tasks = []
    
    if "youtube" in platforms:
        tasks.append(search_youtube_bloggers(keyword))
    if "instagram" in platforms:
        tasks.append(search_instagram_bloggers(keyword))
    if "tiktok" in platforms:
        tasks.append(search_tiktok_bloggers(keyword))
    if "telegram" in platforms:
        tasks.append(search_telegram_bloggers(keyword))
    
    # –í—ã–ø–æ–ª–Ω—è–µ–º –≤—Å–µ –ø–æ–∏—Å–∫–∏ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
    if tasks:
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for result in results:
            if isinstance(result, list):
                all_bloggers.extend(result)
            elif isinstance(result, Exception):
                logger.error(f"–û—à–∏–±–∫–∞ –≤ –ø–æ–∏—Å–∫–µ –±–ª–æ–≥–µ—Ä–æ–≤: {result}")
    
    logger.info(f"üéâ –ù–∞–π–¥–µ–Ω–æ {len(all_bloggers)} —Ä–µ–∞–ª—å–Ω—ã—Ö –±–ª–æ–≥–µ—Ä–æ–≤")
    return all_bloggers

def convert_to_blogger_detail(raw_blogger: Dict, index: int) -> BloggerDetail:
    """–ö–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è —Å—ã—Ä—ã—Ö –¥–∞–Ω–Ω—ã—Ö –±–ª–æ–≥–µ—Ä–∞ –≤ BloggerDetail"""
    
    budget_range = raw_blogger.get('budget_range', (1000, 5000))
    if isinstance(budget_range, str):
        # –ü–∞—Ä—Å–∏–º —Å—Ç—Ä–æ–∫—É –±—é–¥–∂–µ—Ç–∞
        if "50,000-200,000" in budget_range:
            budget_min, budget_max = 50000, 200000
        elif "20,000-100,000" in budget_range:
            budget_min, budget_max = 20000, 100000
        elif "10,000-50,000" in budget_range:
            budget_min, budget_max = 10000, 50000
        elif "5,000-30,000" in budget_range or "5,000-20,000" in budget_range:
            budget_min, budget_max = 5000, 20000
        elif "3,000-15,000" in budget_range:
            budget_min, budget_max = 3000, 15000
        else:
            budget_min, budget_max = 1000, 5000
    else:
        budget_min, budget_max = budget_range
    
    contacts_list = raw_blogger.get('contacts', [])
    telegram_contact = None
    email_contact = None
    
    for contact in contacts_list:
        if contact.startswith('@'):
            telegram_contact = contact
        elif '@' in contact and '.' in contact:
            email_contact = contact
    
    engagement_rate = raw_blogger.get('engagement_rate', 0.0)
    if isinstance(engagement_rate, str):
        engagement_rate = 0.0
    
    avg_views = raw_blogger.get('views', 0)
    followers = raw_blogger.get('followers', 1000)
    
    return BloggerDetail(
        id=1000 + index,
        name=raw_blogger.get('name', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –±–ª–æ–≥–µ—Ä'),
        platform=raw_blogger.get('platform', 'unknown'),
        profile_url=raw_blogger.get('url', ''),
        avatar_url=None,  # –ü–æ–∫–∞ –Ω–µ –∏–∑–≤–ª–µ–∫–∞–µ–º –∞–≤–∞—Ç–∞—Ä—ã
        category=raw_blogger.get('topic', '–û–±—â–∞—è —Ç–µ–º–∞—Ç–∏–∫–∞'),
        followers=followers,
        verified=False,  # –ü–æ–∫–∞ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª—è–µ–º –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—é
        has_wb_content=raw_blogger.get('has_wb_content', False),
        budget_min=budget_min,
        budget_max=budget_max,
        contacts=BloggerContact(
            telegram=telegram_contact,
            email=email_contact
        ),
        stats=BloggerStats(
            avg_views=avg_views,
            avg_likes=int(avg_views * 0.05),  # –ü—Ä–∏–º–µ—Ä–Ω–æ 5% –æ—Ç –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤
            avg_comments=int(avg_views * 0.01),  # –ü—Ä–∏–º–µ—Ä–Ω–æ 1% –æ—Ç –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤
            engagement_rate=engagement_rate,
            posts_per_month=20,  # –ë–∞–∑–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
            wb_mentions=1 if raw_blogger.get('has_wb_content', False) else 0
        ),
        audience=AudienceInsights(
            age_18_24=30.0,
            age_25_34=40.0,
            age_35_44=20.0,
            age_45_plus=10.0,
            male_percentage=45.0,
            female_percentage=55.0,
            top_countries=["–†–æ—Å—Å–∏—è", "–ö–∞–∑–∞—Ö—Å—Ç–∞–Ω"]
        ),
        content_examples=[raw_blogger.get('url', '')],
        country="–†–æ—Å—Å–∏—è",
        description=raw_blogger.get('post_snippet', '')[:200] + "..." if raw_blogger.get('post_snippet') else None,
        is_top_blogger=False,
        brand_friendly=True
    )

def generate_analytics(bloggers: List[BloggerDetail]) -> BloggerAnalytics:
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –ø–æ –Ω–∞–π–¥–µ–Ω–Ω—ã–º –±–ª–æ–≥–µ—Ä–∞–º"""
    
    if not bloggers:
        return BloggerAnalytics(
            total_bloggers=0,
            platform_distribution={},
            avg_followers=0,
            avg_budget=0,
            top_categories=[],
            wb_content_percentage=0,
            top_countries=[]
        )
    
    # –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞–º
    platform_dist = {}
    for blogger in bloggers:
        platform_dist[blogger.platform] = platform_dist.get(blogger.platform, 0) + 1
    
    # –¢–æ–ø –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    category_count = {}
    for blogger in bloggers:
        category_count[blogger.category] = category_count.get(blogger.category, 0) + 1
    
    top_categories = [
        {"name": cat, "count": count} 
        for cat, count in sorted(category_count.items(), key=lambda x: x[1], reverse=True)[:5]
    ]
    
    # –°—Ä–µ–¥–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è
    avg_followers = statistics.mean([b.followers for b in bloggers])
    avg_budget = statistics.mean([(b.budget_min + b.budget_max) / 2 for b in bloggers])
    
    # WB –∫–æ–Ω—Ç–µ–Ω—Ç
    wb_content_count = sum(1 for b in bloggers if b.has_wb_content)
    wb_content_percentage = (wb_content_count / len(bloggers)) * 100
    
    # –¢–æ–ø —Å—Ç—Ä–∞–Ω—ã
    country_count = {}
    for blogger in bloggers:
        if blogger.country:
            country_count[blogger.country] = country_count.get(blogger.country, 0) + 1
    
    top_countries = [country for country, _ in sorted(country_count.items(), key=lambda x: x[1], reverse=True)[:5]]
    
    return BloggerAnalytics(
        total_bloggers=len(bloggers),
        platform_distribution=platform_dist,
        avg_followers=avg_followers,
        avg_budget=avg_budget,
        top_categories=top_categories,
        wb_content_percentage=wb_content_percentage,
        top_countries=top_countries
    )

async def generate_ai_recommendations(keyword: str, bloggers: List[BloggerDetail], analytics: BloggerAnalytics) -> AIRecommendations:
    """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –¥–ª—è –∫–∞–º–ø–∞–Ω–∏–∏ —Å –±–ª–æ–≥–µ—Ä–∞–º–∏"""
    
    try:
        from openai import OpenAI
        
        client = OpenAI(api_key="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")
        
        # –¢–æ–ø –±–ª–æ–≥–µ—Ä—ã –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
        top_bloggers = sorted(bloggers, key=lambda x: x.stats.engagement_rate, reverse=True)[:5]
        
        context = f"""
–ü–æ–∏—Å–∫–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å: {keyword}
–ù–∞–π–¥–µ–Ω–æ —Ä–µ–∞–ª—å–Ω—ã—Ö –±–ª–æ–≥–µ—Ä–æ–≤: {analytics.total_bloggers}
–°—Ä–µ–¥–Ω–∏–µ –ø–æ–¥–ø–∏—Å—á–∏–∫–∏: {analytics.avg_followers:,.0f}
–°—Ä–µ–¥–Ω–∏–π –±—é–¥–∂–µ—Ç: {analytics.avg_budget:,.0f} ‚ÇΩ
–ü—Ä–æ—Ü–µ–Ω—Ç —Å WB –∫–æ–Ω—Ç–µ–Ω—Ç–æ–º: {analytics.wb_content_percentage:.1f}%

–†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞–º:
{chr(10).join([f"- {platform}: {count} –±–ª–æ–≥–µ—Ä–æ–≤" for platform, count in analytics.platform_distribution.items()])}

–¢–æ–ø-5 –±–ª–æ–≥–µ—Ä–æ–≤ –ø–æ –≤–æ–≤–ª–µ—á–µ–Ω–Ω–æ—Å—Ç–∏:
{chr(10).join([f"{i+1}. {blogger.name} ({blogger.platform}): {blogger.followers:,} –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤, {blogger.stats.engagement_rate:.1f}% –≤–æ–≤–ª–µ—á–µ–Ω–Ω–æ—Å—Ç—å, {blogger.budget_min:,}-{blogger.budget_max:,} ‚ÇΩ" for i, blogger in enumerate(top_bloggers)])}

–¢–æ–ø –∫–∞—Ç–µ–≥–æ—Ä–∏–∏:
{chr(10).join([f"- {cat['name']}: {cat['count']} –±–ª–æ–≥–µ—Ä–æ–≤" for cat in analytics.top_categories[:3]])}
"""

        response = await asyncio.to_thread(
            client.chat.completions.create,
            model="gpt-3.5-turbo",
            messages=[
                {
                    "role": "system",
                    "content": "–¢—ã - —ç–∫—Å–ø–µ—Ä—Ç –ø–æ –∏–Ω—Ñ–ª—é–µ–Ω—Å–µ—Ä-–º–∞—Ä–∫–µ—Ç–∏–Ω–≥—É –∏ —Ä–µ–∫–ª–∞–º–µ –≤ —Å–æ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–µ—Ç—è—Ö. –î–∞–π –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –≤—ã–±–æ—Ä—É –±–ª–æ–≥–µ—Ä–æ–≤ –∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –ø—Ä–æ–¥–≤–∏–∂–µ–Ω–∏—è –Ω–∞ —Ä—É—Å—Å–∫–æ–º —è–∑—ã–∫–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ –†–ï–ê–õ–¨–ù–´–• –¥–∞–Ω–Ω—ã—Ö –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –±–ª–æ–≥–µ—Ä–æ–≤."
                },
                {
                    "role": "user",
                    "content": f"{context}\n\n–ù–∞ –æ—Å–Ω–æ–≤–µ –¥–∞–Ω–Ω—ã—Ö –¥–∞–π —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:\n1. –ö–∞–∫–∏–µ 3-5 –±–ª–æ–≥–µ—Ä–æ–≤ –Ω–∞–∏–±–æ–ª–µ–µ –ø–æ–¥—Ö–æ–¥—è—Ç\n2. –ù–∞ –∫–∞–∫–∏—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞—Ö –ª—É—á—à–µ –∑–∞–ø—É—Å—Ç–∏—Ç—å –∫–∞–º–ø–∞–Ω–∏—é\n3. –°—Ç—Ä–∞—Ç–µ–≥–∏—è –±—é–¥–∂–µ—Ç–∞ –∏ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–π\n4. –¢–∏–ø—ã –∫–æ–Ω—Ç–µ–Ω—Ç–∞ (–æ–±–∑–æ—Ä, –∞–Ω–±–æ–∫—Å–∏–Ω–≥, —á–µ–ª–ª–µ–Ω–¥–∂)\n5. –°–æ–≤–µ—Ç—ã –ø–æ –ø–µ—Ä–µ–≥–æ–≤–æ—Ä–∞–º\n6. –û–±—â–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –∫–∞–º–ø–∞–Ω–∏–∏\n7. –û–∂–∏–¥–∞–µ–º—ã–π ROI"
                }
            ],
            max_tokens=1000,
            temperature=0.7
        )
        
        ai_text = response.choices[0].message.content
        
        # –ü–∞—Ä—Å–∏–º –æ—Ç–≤–µ—Ç –∏ –∏–∑–≤–ª–µ–∫–∞–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        return parse_ai_blogger_recommendations(ai_text, top_bloggers)
        
    except Exception as e:
        logger.warning(f"Failed to generate AI recommendations: {e}")
        return generate_fallback_blogger_recommendations(keyword, bloggers, analytics)

def parse_ai_blogger_recommendations(ai_text: str, top_bloggers: List[BloggerDetail]) -> AIRecommendations:
    """–ü–∞—Ä—Å–∏–Ω–≥ AI –æ—Ç–≤–µ—Ç–∞ –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏"""
    
    try:
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã—Ö –±–ª–æ–≥–µ—Ä–æ–≤
        best_bloggers = [blogger.name for blogger in top_bloggers[:3]]
        
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
        platforms = []
        if "youtube" in ai_text.lower() or "—é—Ç—É–±" in ai_text.lower():
            platforms.append("YouTube")
        if "instagram" in ai_text.lower() or "–∏–Ω—Å—Ç–∞–≥—Ä–∞–º" in ai_text.lower():
            platforms.append("Instagram")
        if "tiktok" in ai_text.lower() or "—Ç–∏–∫—Ç–æ–∫" in ai_text.lower():
            platforms.append("TikTok")
        if "telegram" in ai_text.lower() or "—Ç–µ–ª–µ–≥—Ä–∞–º" in ai_text.lower():
            platforms.append("Telegram")
        
        if not platforms:
            platforms = ["YouTube", "Instagram"]  # –î–µ—Ñ–æ–ª—Ç
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º —Å–æ–≤–µ—Ç—ã –ø–æ –∫–æ–Ω—Ç–µ–Ω—Ç—É
        content_suggestions = []
        if "–æ–±–∑–æ—Ä" in ai_text.lower():
            content_suggestions.append("–î–µ—Ç–∞–ª—å–Ω—ã–µ –æ–±–∑–æ—Ä—ã —Ç–æ–≤–∞—Ä–æ–≤")
        if "–∞–Ω–±–æ–∫—Å–∏–Ω–≥" in ai_text.lower() or "—Ä–∞—Å–ø–∞–∫–æ–≤–∫" in ai_text.lower():
            content_suggestions.append("–ê–Ω–±–æ–∫—Å–∏–Ω–≥ –∏ –ø–µ—Ä–≤—ã–µ –≤–ø–µ—á–∞—Ç–ª–µ–Ω–∏—è")
        if "—á–µ–ª–ª–µ–Ω–¥–∂" in ai_text.lower():
            content_suggestions.append("–¢–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ —á–µ–ª–ª–µ–Ω–¥–∂–∏")
        if "—Å—Ä–∞–≤–Ω–µ–Ω" in ai_text.lower():
            content_suggestions.append("–°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–∞–º–∏")
        
        if not content_suggestions:
            content_suggestions = ["–û–±–∑–æ—Ä—ã —Ç–æ–≤–∞—Ä–æ–≤", "–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ lifestyle –∫–æ–Ω—Ç–µ–Ω—Ç"]
        
        return AIRecommendations(
            best_bloggers=best_bloggers,
            recommended_platforms=platforms,
            budget_strategy="–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º –Ω–∞—á–∞—Ç—å —Å –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö –±–ª–æ–≥–µ—Ä–æ–≤ —Å —Ä–µ–∞–ª—å–Ω–æ–π –∞—É–¥–∏—Ç–æ—Ä–∏–µ–π –∏ –æ–ø—ã—Ç–æ–º —Ä–∞–±–æ—Ç—ã —Å WB",
            content_suggestions=content_suggestions,
            negotiation_tips=[
                "–ò–∑—É—á–∏—Ç–µ —Ä–µ–∞–ª—å–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –±–ª–æ–≥–µ—Ä–∞",
                "–ü—Ä–µ–¥–ª–æ–∂–∏—Ç–µ –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–µ —Å–æ—Ç—Ä—É–¥–Ω–∏—á–µ—Å—Ç–≤–æ",
                "–û–±–µ—Å–ø–µ—á—å—Ç–µ –ø—Ä–æ–º–æ–∫–æ–¥—ã –∏ —Å–∫–∏–¥–∫–∏ –¥–ª—è –∞—É–¥–∏—Ç–æ—Ä–∏–∏",
                "–ü—Ä–µ–¥–ª–æ–∂–∏—Ç–µ –±–æ–Ω—É—Å—ã –∑–∞ –≤—ã—Å–æ–∫–∏–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏"
            ],
            campaign_strategy="–§–æ–∫—É—Å –Ω–∞ –±–ª–æ–≥–µ—Ä–∞—Ö —Å —Ä–µ–∞–ª—å–Ω—ã–º –æ–ø—ã—Ç–æ–º —Ä–∞–±–æ—Ç—ã —Å Wildberries",
            expected_roi="ROI –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –∫–∞—á–µ—Å—Ç–≤–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –∏ —Ä–µ–ª–µ–≤–∞–Ω—Ç–Ω–æ—Å—Ç–∏ –∞—É–¥–∏—Ç–æ—Ä–∏–∏ –±–ª–æ–≥–µ—Ä–∞"
        )
        
    except Exception as e:
        logger.warning(f"Failed to parse AI recommendations: {e}")
        return generate_fallback_blogger_recommendations("", [], BloggerAnalytics(
            total_bloggers=0, platform_distribution={}, avg_followers=0, 
            avg_budget=0, top_categories=[], wb_content_percentage=0, top_countries=[]
        ))

def generate_fallback_blogger_recommendations(keyword: str, bloggers: List[BloggerDetail], analytics: BloggerAnalytics) -> AIRecommendations:
    """Fallback —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø—Ä–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ AI"""
    
    top_bloggers = sorted(bloggers, key=lambda x: x.stats.engagement_rate, reverse=True)[:3]
    
    return AIRecommendations(
        best_bloggers=[blogger.name for blogger in top_bloggers],
        recommended_platforms=list(analytics.platform_distribution.keys())[:2] if analytics.platform_distribution else ["YouTube", "Instagram"],
        budget_strategy=f"–†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–π –±—é–¥–∂–µ—Ç: {analytics.avg_budget:,.0f} ‚ÇΩ –Ω–∞ –±–ª–æ–≥–µ—Ä–∞",
        content_suggestions=["–û–±–∑–æ—Ä—ã —Ç–æ–≤–∞—Ä–æ–≤", "–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ lifestyle", "–°—Ä–∞–≤–Ω–µ–Ω–∏—è"],
        negotiation_tips=[
            "–ò–∑—É—á–∏—Ç–µ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Ä–∞–±–æ—Ç—ã –±–ª–æ–≥–µ—Ä–∞",
            "–ü—Ä–µ–¥–ª–æ–∂–∏—Ç–µ –≤–∑–∞–∏–º–æ–≤—ã–≥–æ–¥–Ω—ã–µ —É—Å–ª–æ–≤–∏—è",
            "–û–±—Å—É–¥–∏—Ç–µ –º–µ—Ç—Ä–∏–∫–∏ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏"
        ],
        campaign_strategy="–°–º–µ—à–∞–Ω–Ω–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è: –∫—Ä—É–ø–Ω—ã–µ –±–ª–æ–≥–µ—Ä—ã –¥–ª—è –æ—Ö–≤–∞—Ç–∞ + –º–∏–∫—Ä–æ –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Å–∏–∏",
        expected_roi="ROI –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –∫–∞—á–µ—Å—Ç–≤–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –∏ —Ç–∞—Ä–≥–µ—Ç–∏–Ω–≥–∞"
    )

def apply_filters(bloggers: List[BloggerDetail], request: BloggerSearchRequest) -> List[BloggerDetail]:
    """–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤ –∫ —Å–ø–∏—Å–∫—É –±–ª–æ–≥–µ—Ä–æ–≤"""
    
    filtered = bloggers
    
    # –§–∏–ª—å—Ç—Ä –ø–æ –ø–ª–∞—Ç—Ñ–æ—Ä–º–∞–º
    if request.platforms:
        filtered = [b for b in filtered if b.platform in request.platforms]
    
    # –§–∏–ª—å—Ç—Ä –ø–æ –ø–æ–¥–ø–∏—Å—á–∏–∫–∞–º
    if request.min_followers:
        filtered = [b for b in filtered if b.followers >= request.min_followers]
    if request.max_followers:
        filtered = [b for b in filtered if b.followers <= request.max_followers]
    
    # –§–∏–ª—å—Ç—Ä –ø–æ –±—é–¥–∂–µ—Ç—É
    if request.min_budget:
        filtered = [b for b in filtered if b.budget_max >= request.min_budget]
    if request.max_budget:
        filtered = [b for b in filtered if b.budget_min <= request.max_budget]
    
    # –§–∏–ª—å—Ç—Ä –ø–æ —Å—Ç—Ä–∞–Ω–µ
    if request.country:
        filtered = [b for b in filtered if b.country and request.country.lower() in b.country.lower()]
    
    return filtered

@router.post("/search", response_model=BloggerSearchResponse)
async def search_bloggers(request: BloggerSearchRequest):
    """–ü–æ–∏—Å–∫ —Ä–µ–∞–ª—å–Ω—ã—Ö –±–ª–æ–≥–µ—Ä–æ–≤ —Å —Ñ–∏–ª—å—Ç—Ä–∞–º–∏ –∏ AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è–º–∏"""
    
    try:
        logger.info(f"üîç Real blogger search request: {request.keyword}")
        
        # –ü–æ–∏—Å–∫ —Ä–µ–∞–ª—å–Ω—ã—Ö –±–ª–æ–≥–µ—Ä–æ–≤ —á–µ—Ä–µ–∑ API
        raw_bloggers = await search_real_bloggers(request.keyword, request.platforms)
        
        if not raw_bloggers:
            logger.warning(f"‚ö†Ô∏è No real bloggers found for: {request.keyword}")
            raise HTTPException(status_code=404, detail=f"No real bloggers found for '{request.keyword}' with specified filters.")
        
        # –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ BloggerDetail
        all_bloggers = [convert_to_blogger_detail(raw, idx) for idx, raw in enumerate(raw_bloggers)]
        
        # –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä—ã
        filtered_bloggers = apply_filters(all_bloggers, request)
        
        if not filtered_bloggers:
            logger.warning(f"‚ö†Ô∏è No bloggers found after applying filters for: {request.keyword}")
            raise HTTPException(status_code=404, detail=f"No bloggers found for '{request.keyword}' with specified filters.")
        
        logger.info(f"üìä Found {len(filtered_bloggers)} real bloggers for keyword: {request.keyword}")
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∞–Ω–∞–ª–∏—Ç–∏–∫—É
        analytics = generate_analytics(filtered_bloggers)
        
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º AI —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        ai_recommendations = await generate_ai_recommendations(request.keyword, filtered_bloggers, analytics)
        
        logger.info(f"‚úÖ Real blogger search completed successfully for: {request.keyword}")
        
        return BloggerSearchResponse(
            bloggers=filtered_bloggers,
            analytics=analytics,
            ai_recommendations=ai_recommendations,
            total_found=len(filtered_bloggers)
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"‚ùå Error in real blogger search: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Internal server error: {str(e)}")

@router.post("/export")
async def export_bloggers_xlsx(request: BloggerSearchRequest):
    """–≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö —Ä–µ–∞–ª—å–Ω—ã—Ö –±–ª–æ–≥–µ—Ä–æ–≤ –≤ XLSX —Ñ–∞–π–ª"""
    
    try:
        import pandas as pd
        
        # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –±–ª–æ–≥–µ—Ä–æ–≤
        raw_bloggers = await search_real_bloggers(request.keyword, request.platforms)
        all_bloggers = [convert_to_blogger_detail(raw, idx) for idx, raw in enumerate(raw_bloggers)]
        filtered_bloggers = apply_filters(all_bloggers, request)
        
        if not filtered_bloggers:
            raise HTTPException(status_code=404, detail="No bloggers found for export")
        
        # –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞
        export_data = []
        for blogger in filtered_bloggers:
            export_data.append({
                'Name': blogger.name,
                'Platform': blogger.platform,
                'Category': blogger.category,
                'Followers': blogger.followers,
                'Verified': 'Yes' if blogger.verified else 'No',
                'WB_Content': 'Yes' if blogger.has_wb_content else 'No',
                'Budget_Min': blogger.budget_min,
                'Budget_Max': blogger.budget_max,
                'Engagement_Rate': blogger.stats.engagement_rate,
                'Avg_Views': blogger.stats.avg_views,
                'Avg_Likes': blogger.stats.avg_likes,
                'Avg_Comments': blogger.stats.avg_comments,
                'Posts_Per_Month': blogger.stats.posts_per_month,
                'WB_Mentions': blogger.stats.wb_mentions,
                'Country': blogger.country or '',
                'Female_Percentage': blogger.audience.female_percentage,
                'Male_Percentage': blogger.audience.male_percentage,
                'Age_18_24': blogger.audience.age_18_24,
                'Age_25_34': blogger.audience.age_25_34,
                'Age_35_44': blogger.audience.age_35_44,
                'Age_45_Plus': blogger.audience.age_45_plus,
                'Top_Countries': ', '.join(blogger.audience.top_countries),
                'Profile_URL': blogger.profile_url,
                'Telegram': blogger.contacts.telegram or '',
                'Email': blogger.contacts.email or '',
                'Instagram_DM': blogger.contacts.instagram_dm or '',
                'Description': blogger.description or '',
                'Top_Blogger': 'Yes' if blogger.is_top_blogger else 'No',
                'Brand_Friendly': 'Yes' if blogger.brand_friendly else 'No'
            })
        
        # –°–æ–∑–¥–∞–µ–º DataFrame
        df = pd.DataFrame(export_data)
        
        # –°–æ–∑–¥–∞–µ–º XLSX —Ñ–∞–π–ª –≤ –ø–∞–º—è—Ç–∏
        output = BytesIO()
        with pd.ExcelWriter(output, engine='xlsxwriter') as writer:
            df.to_excel(writer, sheet_name='Real_Bloggers', index=False)
            
            # –ü–æ–ª—É—á–∞–µ–º workbook –∏ worksheet –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
            workbook = writer.book
            worksheet = writer.sheets['Real_Bloggers']
            
            # –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤
            header_format = workbook.add_format({
                'bold': True,
                'text_wrap': True,
                'valign': 'top',
                'fg_color': '#667eea',
                'font_color': 'white',
                'border': 1
            })
            
            # –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫ –∑–∞–≥–æ–ª–æ–≤–∫–∞–º
            for col_num, value in enumerate(df.columns.values):
                worksheet.write(0, col_num, value, header_format)
                
            # –ê–≤—Ç–æ—à–∏—Ä–∏–Ω–∞ –∫–æ–ª–æ–Ω–æ–∫
            for i, col in enumerate(df.columns):
                max_length = max(
                    df[col].astype(str).str.len().max(),
                    len(str(col))
                )
                worksheet.set_column(i, i, min(max_length + 2, 50))
        
        output.seek(0)
        
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ñ–∞–π–ª
        filename = f"real_bloggers_{request.keyword}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"
        
        return StreamingResponse(
            BytesIO(output.getvalue()), 
            media_type='application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
            headers={'Content-Disposition': f'attachment; filename="{filename}"'}
        )
        
    except ImportError:
        raise HTTPException(status_code=500, detail="Excel export requires pandas and xlsxwriter packages")
    except Exception as e:
        logger.error(f"Error in real blogger export: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Error in real blogger export: {str(e)}")

@router.get("/platforms")
async def get_available_platforms():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –ø–ª–∞—Ç—Ñ–æ—Ä–º"""
    return {
        "platforms": [
            {"id": "youtube", "name": "YouTube", "icon": "üé¨"},
            {"id": "instagram", "name": "Instagram", "icon": "üì∑"},
            {"id": "tiktok", "name": "TikTok", "icon": "üéµ"},
            {"id": "telegram", "name": "Telegram", "icon": "‚úàÔ∏è"}
        ]
    }

@router.get("/categories")
async def get_available_categories():
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –∫–∞—Ç–µ–≥–æ—Ä–∏–π"""
    return {
        "categories": [
            "–°–ø–æ—Ä—Ç –∏ —Ñ–∏—Ç–Ω–µ—Å",
            "–ö—Ä–∞—Å–æ—Ç–∞ –∏ –∫–æ—Å–º–µ—Ç–∏–∫–∞", 
            "–î–æ–º –∏ –∏–Ω—Ç–µ—Ä—å–µ—Ä",
            "–¢–µ—Ö–Ω–æ–ª–æ–≥–∏–∏",
            "–ï–¥–∞ –∏ –∫—É–ª–∏–Ω–∞—Ä–∏—è",
            "–ú–æ–¥–∞ –∏ —Å—Ç–∏–ª—å",
            "–ü—É—Ç–µ—à–µ—Å—Ç–≤–∏—è",
            "–ê–≤—Ç–æ",
            "–ò–≥—Ä—ã",
            "–û–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ"
        ]
    } 